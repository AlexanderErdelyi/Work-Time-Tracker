name: Create Release

'on':
  push:
    tags:
      - 'v*.*.*'  # Triggers on version tags like v1.0.0
  workflow_dispatch:  # Allows manual triggering
    inputs:
      tag:
        description: 'Tag to release (e.g., v1.0.0)'
        required: true
        type: string

jobs:
  build-and-release:
    name: Build and Release
    runs-on: windows-latest
    permissions:
      contents: write  # Required to create releases and upload assets
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # For workflow_dispatch, checkout main and create tag; for push, checkout the tag
          ref: ${{ github.event_name == 'workflow_dispatch' && 'main' || github.ref }}
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
      
      - name: Setup Inno Setup
        shell: pwsh
        run: |
          Write-Host "Installing Inno Setup..."
          # Download Inno Setup
          $installerUrl = "https://jrsoftware.org/download.php/is.exe"
          $installerPath = "$env:TEMP\innosetup.exe"
          Invoke-WebRequest -Uri $installerUrl -OutFile $installerPath
          
          # Install silently
          Start-Process -FilePath $installerPath -ArgumentList "/VERYSILENT", "/SUPPRESSMSGBOXES", "/NORESTART", "/SP-" -Wait
          
          # Add to PATH
          $innoPath = "${env:ProgramFiles(x86)}\Inno Setup 6"
          echo "$innoPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          
          Write-Host "Inno Setup installed successfully"
      
      - name: Extract version from tag
        id: get_version
        shell: pwsh
        run: |
          # Get tag name from either push event or manual input
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            $tagName = "${{ inputs.tag }}"
          } else {
            $tagName = "${{ github.ref_name }}"
          }
          
          $version = $tagName -replace '^v', ''
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          echo "TAG_NAME=$tagName" >> $env:GITHUB_OUTPUT
          echo "Building version: $version"
      
      - name: Create and push tag (workflow_dispatch only)
        if: github.event_name == 'workflow_dispatch'
        shell: pwsh
        run: |
          $tagName = "${{ steps.get_version.outputs.TAG_NAME }}"
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check if tag already exists remotely
          git fetch --tags
          
          # Check if tag exists (redirect stderr to avoid noise)
          git rev-parse "$tagName" 2>$null
          if ($LASTEXITCODE -eq 0) {
            Write-Host "Tag $tagName already exists, skipping creation"
          }
          else {
            # Tag doesn't exist, create and push it
            git tag -a "$tagName" -m "Release $tagName"
            git push origin "$tagName"
            Write-Host "Created and pushed tag $tagName"
          }
      
      - name: Update version.json
        shell: pwsh
        run: |
          $version = "${{ steps.get_version.outputs.VERSION }}"
          $versionFile = Get-Content "version.json" | ConvertFrom-Json
          $versionFile.version = $version
          $versionFile.releaseDate = (Get-Date -Format "yyyy-MM-dd")
          $versionFile | ConvertTo-Json -Depth 10 | Set-Content "version.json"
      
      - name: Setup code signing
        shell: pwsh
        run: |
          Write-Host "Setting up code signing..."
          
          # Check if commercial certificate is available
          $certBase64 = "${{ secrets.CERTIFICATE_BASE64 }}"
          
          if ($certBase64 -and $certBase64 -ne "") {
            Write-Host "Using commercial certificate from secrets..."
            
            # Decode certificate from base64
            $certBytes = [System.Convert]::FromBase64String($certBase64)
            $certPath = Join-Path $env:RUNNER_TEMP "certificate.pfx"
            [System.IO.File]::WriteAllBytes($certPath, $certBytes)
            
            # Set environment variables for signing with commercial cert
            echo "SIGN_ENABLED=true" >> $env:GITHUB_ENV
            echo "CERTIFICATE_PATH=$certPath" >> $env:GITHUB_ENV
            echo "CERTIFICATE_PASSWORD=${{ secrets.CERTIFICATE_PASSWORD }}" >> $env:GITHUB_ENV
            echo "TIMESTAMP_SERVER=http://timestamp.digicert.com" >> $env:GITHUB_ENV
            
            Write-Host "âœ“ Commercial certificate configured"
          } else {
            Write-Host "No commercial certificate found. Creating self-signed certificate..."
            
            # Create a self-signed certificate for code signing
            $cert = New-SelfSignedCertificate `
              -Type CodeSigningCert `
              -Subject "CN=Timekeeper Self-Signed Certificate" `
              -KeyUsage DigitalSignature `
              -FriendlyName "Timekeeper Code Signing (Self-Signed)" `
              -CertStoreLocation "Cert:\CurrentUser\My" `
              -TextExtension @("2.5.29.37={text}1.3.6.1.5.5.7.3.3") `
              -KeyAlgorithm RSA `
              -KeyLength 2048 `
              -NotAfter (Get-Date).AddYears(5)
            
            # Export to PFX file
            $password = ConvertTo-SecureString -String "temp-self-signed-password" -Force -AsPlainText
            $certPath = Join-Path $env:RUNNER_TEMP "self-signed-certificate.pfx"
            Export-PfxCertificate -Cert $cert -FilePath $certPath -Password $password | Out-Null
            
            # Set environment variables for signing with self-signed cert
            echo "SIGN_ENABLED=true" >> $env:GITHUB_ENV
            echo "CERTIFICATE_PATH=$certPath" >> $env:GITHUB_ENV
            echo "CERTIFICATE_PASSWORD=temp-self-signed-password" >> $env:GITHUB_ENV
            echo "TIMESTAMP_SERVER=http://timestamp.digicert.com" >> $env:GITHUB_ENV
            
            Write-Host "âœ“ Self-signed certificate created and configured"
            Write-Host "âš  Note: Self-signed certificates will still show security warnings to end users"
            Write-Host "   For production, use a commercial certificate from DigiCert, Sectigo, etc."
          }
          
          Write-Host ""
      
      - name: Build self-contained application
        shell: pwsh
        run: |
          $version = "${{ steps.get_version.outputs.VERSION }}"
          
          # Import code signing module
          Import-Module "${{ github.workspace }}\CodeSigning.psm1" -Force
          
          # Create Release directory
          New-Item -ItemType Directory -Path ".\Release" -Force | Out-Null
          
          # Publish self-contained for Windows x64
          # Note: We do NOT use PublishSingleFile for the API so that Timekeeper.Api.dll
          # remains as a separate file, which allows the "dotnet Timekeeper.Api.dll" command
          # to work in security-restricted environments.
          # We also do NOT use PublishTrimmed to avoid runtime issues with EF Core and MVC.
          dotnet publish Timekeeper.Api/Timekeeper.Api.csproj `
            --configuration Release `
            --runtime win-x64 `
            --self-contained true `
            --output ".\Release\Timekeeper-v$version-win-x64"
          
          # Publish Tray App (system tray launcher)
          dotnet publish Timekeeper.TrayApp/Timekeeper.TrayApp.csproj `
            --configuration Release `
            --runtime win-x64 `
            --self-contained true `
            --output ".\Release\Timekeeper-v$version-win-x64" `
            /p:PublishSingleFile=true `
            /p:EnableCompressionInSingleFile=true
          
          $distFolder = ".\Release\Timekeeper-v$version-win-x64"
          
          # Sign executables if signing is enabled
          if ($env:SIGN_ENABLED -eq "true") {
              Write-Host ""
              Write-Host "Code Signing Executables..." -ForegroundColor Yellow
              $signedCount = 0
              
              $apiExe = Join-Path $distFolder "Timekeeper.Api.exe"
              $trayExe = Join-Path $distFolder "Timekeeper.TrayApp.exe"
              
              if (Test-Path $apiExe) {
                  if (Sign-File -FilePath $apiExe) { $signedCount++ }
              }
              
              if (Test-Path $trayExe) {
                  if (Sign-File -FilePath $trayExe) { $signedCount++ }
              }
              
              if ($signedCount -gt 0) {
                  Write-Host "   Successfully signed $signedCount file(s)" -ForegroundColor Green
              }
              Write-Host ""
          }
          
          # Copy documentation
          Copy-Item ".\README.md" -Destination $distFolder
          Copy-Item ".\SETUP_GUIDE.md" -Destination $distFolder
          Copy-Item ".\SIMPLE_USER_GUIDE.md" -Destination $distFolder
          Copy-Item ".\DISTRIBUTION_GUIDE.md" -Destination $distFolder
          Copy-Item ".\version.json" -Destination $distFolder
          
          # Create START_HERE.txt
          $startHere = "# Timekeeper v$version`n`n"
          $startHere += "## Quick Start`n`n"
          $startHere += "### Option 1: System Tray (Recommended)`n"
          $startHere += "- Double-click Timekeeper.TrayApp.exe`n"
          $startHere += "- The app will run in the system tray (bottom-right icons)`n"
          $startHere += "- Right-click the tray icon to start/stop or open the app`n"
          $startHere += "- No console window will appear!`n`n"
          $startHere += "### Option 2: Command Window`n"
          $startHere += "- Double-click START_TIMEKEEPER.bat`n"
          $startHere += "- Your browser will open automatically`n"
          $startHere += "- A console window will remain open`n`n"
          $startHere += "### Option 3: For Security-Restricted Systems (Company Laptops)`n"
          $startHere += "If Option 1 or 2 gives 'Access Denied' errors:`n"
          $startHere += "- Double-click RUN_WITH_DOTNET.bat`n"
          $startHere += "- OR right-click RUN_WITH_DOTNET.ps1 and select 'Run with PowerShell'`n"
          $startHere += "- These use 'dotnet' command which may bypass security restrictions`n`n"
          $startHere += "### To Stop:`n"
          $startHere += "- System Tray: Right-click tray icon > Exit`n"
          $startHere += "- Command Window: Close the console window or press Ctrl+C`n`n"
          $startHere += "## Your Data`n"
          $startHere += "All your data is saved in 'timekeeper.db' in this folder.`n"
          $startHere += "**IMPORTANT**: Backup this file regularly!`n`n"
          $startHere += "## Need Help?`n"
          $startHere += "See SIMPLE_USER_GUIDE.md for detailed instructions.`n`n"
          $startHere += "## Features`n"
          $startHere += "- No installation required - everything is included!`n"
          $startHere += "- No .NET Runtime needed`n"
          $startHere += "- Your data stays on your computer`n"
          $startHere += "- Offline application - works without internet`n"
          $startHere += "- Runs in system tray - no disturbing windows!`n`n"
          $startHere += "Enjoy!`n"
          
          Set-Content -Path "$distFolder\START_HERE.txt" -Value $startHere -Encoding UTF8
          
          # Create START_TIMEKEEPER.bat (legacy option)
          $batchContent = "@echo off`r`n"
          $batchContent += "title Timekeeper - Time Tracking Application`r`n"
          $batchContent += "echo.`r`n"
          $batchContent += "echo ================================================`r`n"
          $batchContent += "echo   Timekeeper is starting...`r`n"
          $batchContent += "echo ================================================`r`n"
          $batchContent += "echo.`r`n"
          $batchContent += "echo The application will open in your default browser.`r`n"
          $batchContent += "echo If it doesn't open automatically, go to:`r`n"
          $batchContent += "echo.`r`n"
          $batchContent += "echo    http://localhost:5000`r`n"
          $batchContent += "echo.`r`n"
          $batchContent += "echo To STOP the application, close this window or press Ctrl+C`r`n"
          $batchContent += "echo.`r`n"
          $batchContent += "echo ================================================`r`n"
          $batchContent += "echo.`r`n"
          $batchContent += "`r`n"
          $batchContent += "start http://localhost:5000`r`n"
          $batchContent += "`r`n"
          $batchContent += "Timekeeper.Api.exe`r`n"
          $batchContent += "`r`n"
          $batchContent += "pause`r`n"
          
          Set-Content -Path "$distFolder\START_TIMEKEEPER.bat" -Value $batchContent -Encoding ASCII
          
          # Create RUN_WITH_DOTNET.bat for security-restricted environments
          $dotnetBatchContent = "@echo off`r`n"
          $dotnetBatchContent += "title Timekeeper - Time Tracking Application (dotnet launcher)`r`n"
          $dotnetBatchContent += "echo.`r`n"
          $dotnetBatchContent += "echo ================================================`r`n"
          $dotnetBatchContent += "echo   Timekeeper is starting with dotnet...`r`n"
          $dotnetBatchContent += "echo ================================================`r`n"
          $dotnetBatchContent += "echo.`r`n"
          $dotnetBatchContent += "echo This launcher runs the app using 'dotnet' command`r`n"
          $dotnetBatchContent += "echo which may work better on security-restricted systems.`r`n"
          $dotnetBatchContent += "echo.`r`n"
          $dotnetBatchContent += "echo The application will open in your default browser.`r`n"
          $dotnetBatchContent += "echo If it doesn't open automatically, go to:`r`n"
          $dotnetBatchContent += "echo.`r`n"
          $dotnetBatchContent += "echo    http://localhost:5000`r`n"
          $dotnetBatchContent += "echo.`r`n"
          $dotnetBatchContent += "echo To STOP the application, close this window or press Ctrl+C`r`n"
          $dotnetBatchContent += "echo.`r`n"
          $dotnetBatchContent += "echo ================================================`r`n"
          $dotnetBatchContent += "echo.`r`n"
          $dotnetBatchContent += "`r`n"
          $dotnetBatchContent += "start http://localhost:5000`r`n"
          $dotnetBatchContent += "`r`n"
          $dotnetBatchContent += "dotnet `"%~dp0Timekeeper.Api.dll`"`r`n"
          $dotnetBatchContent += "`r`n"
          $dotnetBatchContent += "pause`r`n"
          
          Set-Content -Path "$distFolder\RUN_WITH_DOTNET.bat" -Value $dotnetBatchContent -Encoding ASCII
          
          # Create RUN_WITH_DOTNET.ps1 as PowerShell alternative
          $dotnetPsContent = "# Timekeeper Launcher - PowerShell Version`n"
          $dotnetPsContent += "# This launcher runs the app using 'dotnet' command`n"
          $dotnetPsContent += "# which may work better on security-restricted systems.`n`n"
          $dotnetPsContent += "Write-Host `"`" `n"
          $dotnetPsContent += "Write-Host `"================================================`" -ForegroundColor Cyan`n"
          $dotnetPsContent += "Write-Host `"  Timekeeper is starting with dotnet...`" -ForegroundColor Cyan`n"
          $dotnetPsContent += "Write-Host `"================================================`" -ForegroundColor Cyan`n"
          $dotnetPsContent += "Write-Host `"`" `n"
          $dotnetPsContent += "Write-Host `"This launcher runs the app using 'dotnet' command`" -ForegroundColor Yellow`n"
          $dotnetPsContent += "Write-Host `"which may work better on security-restricted systems.`" -ForegroundColor Yellow`n"
          $dotnetPsContent += "Write-Host `"`" `n"
          $dotnetPsContent += "Write-Host `"The application will open in your default browser.`" -ForegroundColor Green`n"
          $dotnetPsContent += "Write-Host `"If it doesn't open automatically, go to:`" -ForegroundColor Green`n"
          $dotnetPsContent += "Write-Host `"`" `n"
          $dotnetPsContent += "Write-Host `"   http://localhost:5000`" -ForegroundColor White`n"
          $dotnetPsContent += "Write-Host `"`" `n"
          $dotnetPsContent += "Write-Host `"To STOP the application, press Ctrl+C`" -ForegroundColor Yellow`n"
          $dotnetPsContent += "Write-Host `"`" `n"
          $dotnetPsContent += "Write-Host `"================================================`" -ForegroundColor Cyan`n"
          $dotnetPsContent += "Write-Host `"`" `n`n"
          $dotnetPsContent += "# Open browser`n"
          $dotnetPsContent += "Start-Process `"http://localhost:5000`"`n`n"
          $dotnetPsContent += "# Run the application with dotnet`n"
          $dotnetPsContent += "`$dllPath = Join-Path `$PSScriptRoot `"Timekeeper.Api.dll`"`n"
          $dotnetPsContent += "& dotnet `$dllPath`n"
          
          Set-Content -Path "$distFolder\RUN_WITH_DOTNET.ps1" -Value $dotnetPsContent -Encoding UTF8
          
          # Create ZIP
          $zipPath = ".\Release\Timekeeper-v$version-win-x64.zip"
          Compress-Archive -Path $distFolder -DestinationPath $zipPath -Force
      
      - name: Build Windows Installer
        shell: pwsh
        run: |
          $version = "${{ steps.get_version.outputs.VERSION }}"
          
          # Import code signing module
          Import-Module "${{ github.workspace }}\CodeSigning.psm1" -Force
          
          Write-Host "Building Windows Installer with Inno Setup..."
          
          # Set environment variable for version
          $env:APP_VERSION = $version
          
          # Verify source directory exists
          $distFolder = ".\Release\Timekeeper-v$version-win-x64"
          if (-not (Test-Path $distFolder)) {
            Write-Host "ERROR: Distribution folder not found: $distFolder" -ForegroundColor Red
            exit 1
          }
          
          Write-Host "Distribution folder verified: $distFolder"
          
          # Use full path to ISCC.exe
          $isccPath = "${env:ProgramFiles(x86)}\Inno Setup 6\ISCC.exe"
          if (-not (Test-Path $isccPath)) {
            Write-Host "ERROR: ISCC.exe not found at: $isccPath" -ForegroundColor Red
            exit 1
          }
          
          # Build installer
          & $isccPath "installer.iss"
          
          if ($LASTEXITCODE -eq 0) {
            Write-Host "Installer created successfully!"
            $installerPath = ".\Release\Timekeeper-v$version-win-x64-installer.exe"
            if (Test-Path $installerPath) {
              $size = [math]::Round((Get-Item $installerPath).Length / 1MB, 2)
              Write-Host "Installer size: $size MB"
              
              # Sign the installer
              if ($env:SIGN_ENABLED -eq "true") {
                  Write-Host ""
                  Write-Host "Signing installer..." -ForegroundColor Yellow
                  if (Sign-File -FilePath $installerPath) {
                      Write-Host "âœ“ Installer signed successfully" -ForegroundColor Green
                  } else {
                      Write-Host "âš  Installer signing failed" -ForegroundColor Yellow
                  }
                  Write-Host ""
              }
              
              # Create ZIP file containing the installer for office environments that block .exe downloads
              Write-Host "Creating ZIP package for installer..."
              $installerZipPath = ".\Release\Timekeeper-v$version-win-x64-installer.zip"
              Compress-Archive -Path $installerPath -DestinationPath $installerZipPath -Force
              $zipSize = [math]::Round((Get-Item $installerZipPath).Length / 1MB, 2)
              Write-Host "Installer ZIP created: $zipSize MB"
            } else {
              Write-Host "ERROR: Installer file not found at expected location!" -ForegroundColor Red
              exit 1
            }
          } else {
            Write-Host "Installer build failed!" -ForegroundColor Red
            exit 1
          }
      
      - name: Generate release notes
        id: release_notes
        shell: pwsh
        run: |
          $version = "${{ steps.get_version.outputs.VERSION }}"
          
          # Read changelog from version.json
          $versionFile = Get-Content "version.json" | ConvertFrom-Json
          $changelog = $versionFile.changelog.$version
          
          $releaseNotes = "# Timekeeper v$version`n`n"
          $releaseNotes += "Released: $(Get-Date -Format 'yyyy-MM-dd')`n`n"
          $releaseNotes += "## âœ¨ What's New`n`n"
          
          if ($changelog -and $changelog.changes) {
            foreach ($change in $changelog.changes) {
              $releaseNotes += "- $change`n"
            }
          } else {
            $releaseNotes += "- See version.json for details`n"
          }
          
          $releaseNotes += "`n`n## ðŸ“¥ Download & Installation`n`n"
          $releaseNotes += "### Option 1: Windows Installer (Easiest) â­`n`n"
          $releaseNotes += "1. Download **Timekeeper-v$version-win-x64-installer.exe** below`n"
          $releaseNotes += "2. Run the installer`n"
          $releaseNotes += "3. Follow the installation wizard`n"
          $releaseNotes += "4. Launch from Start Menu or Desktop shortcut`n"
          $releaseNotes += "5. Uninstall anytime from Windows Settings > Apps`n`n"
          $releaseNotes += "**ðŸ¢ Office/Corporate Network?** If your firewall blocks .exe downloads, download **Timekeeper-v$version-win-x64-installer.zip** instead, extract it, then run the installer inside.`n`n"
          $releaseNotes += "### Option 2: Portable ZIP (No Installation) ðŸŒŸ`n`n"
          $releaseNotes += "1. Download **Timekeeper-v$version-win-x64.zip** below`n"
          $releaseNotes += "2. Extract the ZIP file to any folder`n"
          $releaseNotes += "3. Double-click **START_TIMEKEEPER.bat**`n"
          $releaseNotes += "4. Your browser opens automatically - start tracking time!`n`n"
          $releaseNotes += "**No installation required! No .NET needed!**`n`n"
          $releaseNotes += "ðŸ“– See **SIMPLE_USER_GUIDE.md** (included in ZIP) for detailed instructions.`n`n"
          $releaseNotes += "### Features`n`n"
          
          if ($versionFile.features) {
            foreach ($feature in $versionFile.features) {
              $releaseNotes += "- $feature`n"
            }
          }
          
          $releaseNotes += "`n`n### âš™ï¸ Requirements`n`n"
          $releaseNotes += "- Windows 10 or 11 (64-bit)`n"
          $releaseNotes += "- No other software needed!`n`n"
          $releaseNotes += "### ðŸ“ Important Notes`n`n"
          $releaseNotes += "- **Your data**: Stored in ``timekeeper.db`` file - backup regularly!`n"
          $releaseNotes += "- **Offline**: Works without internet connection`n"
          $releaseNotes += "- **Privacy**: All data stays on your computer`n"
          $releaseNotes += "- **Portable**: Copy folder to USB or anywhere`n`n"
          $releaseNotes += "### ðŸ†˜ Need Help?`n`n"
          $releaseNotes += "- Read **SIMPLE_USER_GUIDE.md** for step-by-step instructions`n"
          $releaseNotes += "- Check **SETUP_GUIDE.md** for troubleshooting`n"
          $releaseNotes += "- Open an issue on GitHub`n`n"
          $releaseNotes += "---`n`n"
          $releaseNotes += "## ðŸ”„ Updating from Previous Version`n`n"
          $releaseNotes += "1. Backup your **timekeeper.db** file`n"
          $releaseNotes += "2. Download and extract new version`n"
          $releaseNotes += "3. Copy your **timekeeper.db** into new folder`n"
          $releaseNotes += "4. Run START_TIMEKEEPER.bat`n`n"
          $releaseNotes += "Your data will be preserved! âœ…`n"
          
          # Save to file for GitHub release
          $releaseNotes | Out-File -FilePath "release_notes.md" -Encoding UTF8
          
          # Set output (escape for GitHub Actions)
          $releaseNotes = $releaseNotes -replace '%','%25' -replace '\n','%0A' -replace '\r','%0D'
          echo "NOTES=$releaseNotes" >> $env:GITHUB_OUTPUT
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.get_version.outputs.TAG_NAME }}
          name: Timekeeper v${{ steps.get_version.outputs.VERSION }}
          body_path: release_notes.md
          files: |
            Release/Timekeeper-v${{ steps.get_version.outputs.VERSION }}-win-x64.zip
            Release/Timekeeper-v${{ steps.get_version.outputs.VERSION }}-win-x64-installer.exe
            Release/Timekeeper-v${{ steps.get_version.outputs.VERSION }}-win-x64-installer.zip
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
